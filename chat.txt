below is the readme and implementation of a simple functional programming language
./README.md
# FP

A simple functional programming language in 130 lines of code with `functions as first-class citizens`. $\mathbb{F}_p$ also denotes the finite field of order $p$ 

## How to use?

A REPL is available by running `go run bin/repl/main.go`. An example program is at `example.lisp`.

Have fun ðŸ¤—

## How to implement data structures like list, dict

data structures can be implemented using functions, example below

floating point is useful

## How to handle infix operator?

translate `[<expr_1> <name_1> <expr_2> <name_2> <expr_3>]` into `(<name_1> <expr_1> (<name_2> <expr_2> <expr_3>))` - todo 
## Isn't `(let x 3)` equivalent to `(let x (lambda 3))`?

yes, if functions are pure, then we can consider `(let x <expr>)` as a pure function of the form `(let x (lambda <expr>))`. 
however, if functions are not pure, if `x` is defined locally, `(let f (lambda (x + 3)))` and `let f (x + 3)` are different
since variables are evaluated at definition but functions are only evaluated when it is called,
that is if we pass `f` outside of the function, it no longer valid.
in the code below, i gave an example with `(let x_v (print 2 5))` and `(func x_f (print 2 6))`

## How to handle higher-order functions

higher-order function is already implemented

## Tail call optimization

WIP

## Performance improvement

if we assume functions are pure, one can consider the whole program as a set of expressions (with some dependencies of `let`)
each function call only need its own variable scope, they can execute every expression at the same time (possibly with some waiting for `let` statement) 

## But can it run Doom?

no ðŸ˜…

## MANUAL 

- for builtin modules, extensions, see `MANUAL.md`
- wildcard symbol: `_` is a special symbol used in `case` to mark every other cases
- no match is `case` is an undefined behavior

## a simple program

- see `example.lisp`./MANUAL.md
```
welcome to fp repl! type <function or module name> for help
>>>add
extension: (add 1 (add 2 3) 3) - exec a sequence of expressions and return the sum
>>>append
extension: (append l 2 (add 1 1)) - append elements into list l and return a new list
>>>case
module: (case x 1 2 4 5) - case, if x=1 then return 3, if x=4 the return 5
>>>del
module: (del x) - delete variable x
>>>div
extension: division
>>>lambda
module: (lambda x y (add x y) - declare a function
>>>let
module: (let x 3) - assign value 3 to local variable x
>>>list
extension: (list 1 2 (lambda x (add x 1))) - make a list
>>>map
extension: (map l (lambda y (add 1 y))) - map
>>>mod
extension: (mod 2 (add 1 1)) - exec two expressions and return modulo
>>>mul
extension: (mul 1 (add 2 3) 3) - exec a sequence of expressions and return the product
>>>peak
extension: (peak l 3 2) - get elem from list (can get multiple elements)
>>>print
extension: (print 1 x (lambda 3)) - print values
>>>reset
module: (reset) - reset stack
>>>sign
extension: (sign 3) - exec an expression and return the sign
>>>slice
extension: (slice l 2 3) - make a slice of a list l[2, 3]
>>>stack
module: (stack) - get stack
>>>sub
extension: (sub 2 (add 1 1)) - exec two expressions and return difference
>>>tail
extension: (tail (print 1) (print 2) 3) - exec a sequence of expressions and return the last one
>>>type
extension: (type x 1 (lambda y (add 1 y))) - get types of objects (can get multiple ones)
```
./cmd/man/main.go
package main

import (
	"fmt"
	"fp/pkg/fp"
	"os"
	"sort"
)

func write(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(os.Stderr, format, args...)
	_ = os.Stderr.Sync() // flush
}

func writeln(format string, args ...interface{}) {
	write(format+"\n", args...)
}

func main() {
	r := fp.NewStdRuntime().
		LoadExtension("div", fp.Extension{
			Exec: func(value ...fp.Object) (fp.Object, error) {
				if len(value) != 2 {
					return nil, fmt.Errorf("subtract requires 2 arguments")
				}
				a, ok := value[0].(int)
				if !ok {
					return nil, fmt.Errorf("subtract non-integer value")
				}
				b, ok := value[0].(int)
				if !ok {
					return nil, fmt.Errorf("subtract non-integer value")
				}
				if b == 0 {
					return nil, fmt.Errorf("division by zero")
				}
				return a / b, nil
			},
			Man: "extension: division",
		})
	writeln("welcome to fp repl! type <function or module name> for help")
	var funcNameList []string
	for k := range r.Stack[0] {
		funcNameList = append(funcNameList, string(k))
	}
	sort.Strings(funcNameList)
	for _, name := range funcNameList {
		o, err := r.Step(fp.Name(name))
		if err != nil {
			panic(err)
		}
		writeln(">>>%s", name)
		writeln("%v", o)
	}
}
./cmd/repl/main.go
package main

import (
	"bufio"
	"fmt"
	"fp/pkg/fp"
	"os"
	"os/signal"
	"sort"
	"syscall"
)

func write(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(os.Stderr, format, args...)
	_ = os.Stderr.Sync() // flush
}

func writeln(format string, args ...interface{}) {
	write(format+"\n", args...)
}

func main() {
	r := fp.NewStdRuntime().
		LoadExtension("div", fp.Extension{
			Exec: func(value ...fp.Object) (fp.Object, error) {
				if len(value) != 2 {
					return nil, fmt.Errorf("subtract requires 2 arguments")
				}
				a, ok := value[0].(int)
				if !ok {
					return nil, fmt.Errorf("subtract non-integer value")
				}
				b, ok := value[0].(int)
				if !ok {
					return nil, fmt.Errorf("subtract non-integer value")
				}
				if b == 0 {
					return nil, fmt.Errorf("division by zero")
				}
				return a / b, nil
			},
			Man: "extension: division",
		})
	writeln("welcome to fp repl! type <function or module name> for help")
	write("loaded modules: ")
	var funcNameList []string
	for k := range r.Stack[0] {
		funcNameList = append(funcNameList, string(k))
	}
	sort.Strings(funcNameList)
	for _, name := range funcNameList {
		write("%s ", name)
	}
	writeln("")

	signCh := make(chan os.Signal, 1)
	signal.Notify(signCh, syscall.SIGINT, syscall.SIGTERM)

	parser := &fp.Parser{}

	scanner := bufio.NewScanner(os.Stdin)
	write(">>>")
	for scanner.Scan() {
		select {
		case <-signCh:
			parser.Clear()
			writeln(">>> (Control + C) to clear buffer, (Control + D) to exit")
			writeln(">>>")
		default:
			line := scanner.Text()
			tokenList := fp.Tokenize(line)
			executed := false
			if len(tokenList) == 0 {
				executed = true
			} else {
				for _, token := range tokenList {
					expr := parser.Input(token)
					if expr != nil {
						executed = true
						output, err := r.Step(expr)
						if err != nil {
							writeln(err.Error())
							continue
						}
						write("%v\n", output)
					}
				}
			}
			if executed {
				write(">>>")
			}
		}

	}
	if err := scanner.Err(); err != nil {
		panic(err)
	}
}
./pkg/fp/runtime_step.go
package fp

import (
	"fmt"
	"os"
)

const DETECT_NONPURE = true

func (r *Runtime) searchOnStack(name Name) (Object, error) {
	for i := len(r.Stack) - 1; i >= 0; i-- {
		if o, ok := r.Stack[i][name]; ok {
			if DETECT_NONPURE && i != 0 && i < len(r.Stack)-1 {
				_, _ = fmt.Fprintf(os.Stderr, "non-pure function")
			}
			return o, nil
		}
	}
	return nil, fmt.Errorf("object not found %s", name)
}

// Step - implement minimal set of instructions for the language to be Turing complete
// let, Lambda, case, sign, sub, add, tail
func (r *Runtime) Step(expr Expr) (Object, error) {
	switch expr := expr.(type) {
	case Name:
		var v Object
		// parse name
		v, err := r.parseLiteral(expr)
		if err == nil {
			return v, nil
		}
		// find in stack for variable
		return r.searchOnStack(expr)

	case LambdaExpr:
		f, err := r.searchOnStack(expr.Name)
		if err != nil {
			return nil, err
		}
		switch f := f.(type) {
		case Lambda:
			// 1. evaluate arguments
			args, err := r.stepMany(expr.Args...)
			if err != nil {
				return nil, err
			}
			// 2. add argument to local Frame
			localFrame := make(Frame).Update(f.Frame)
			for i := 0; i < len(f.Params); i++ {
				localFrame[f.Params[i]] = args[i]
			}
			// 3. push Frame to Stack
			r.Stack = append(r.Stack, localFrame)
			// 4. exec function
			v, err := r.Step(f.Impl)
			if err != nil {
				return nil, err
			}
			// 5. pop Frame from Stack
			r.Stack = r.Stack[:len(r.Stack)-1]
			return v, nil
		case Module:
			return f.Exec(r, expr)
		default:
			return nil, fmt.Errorf("function or module %s found but wrong type", expr.Name.String())
		}
	default:
		return nil, fmt.Errorf("runtime error: unknown expression type")
	}
}

func (r *Runtime) stepMany(exprList ...Expr) ([]Object, error) {
	var outputs []Object
	for _, expr := range exprList {
		v, err := r.Step(expr)
		if err != nil {
			return nil, err
		}
		outputs = append(outputs, v)
	}
	return outputs, nil
}
./pkg/fp/runtime.go
package fp

import (
	"strconv"
)

// NewPlainRuntime - runtime + core control flow extensions
func NewPlainRuntime() *Runtime {
	return (&Runtime{
		parseLiteral: func(lit Name) (Object, error) {
			return strconv.Atoi(lit.String())
		},
		Stack: []Frame{
			make(Frame),
		},
	}).
		LoadModule("let", letModule).
		LoadModule("del", delModule).
		LoadModule("lambda", lambdaModule).
		LoadModule("case", caseModule)
}

// NewBasicRuntime : NewPlainRuntime + minimal set of arithmetic extensions for Turing completeness
func NewBasicRuntime() *Runtime {
	return NewPlainRuntime().
		LoadModule("reset", resetModule).
		LoadExtension("tail", tailExtension).
		LoadExtension("add", addExtension).
		LoadExtension("sub", subExtension).
		LoadExtension("sign", signExtension)
}

// NewStdRuntime : NewPlainRuntime + standard functions
func NewStdRuntime() *Runtime {
	return NewBasicRuntime().
		LoadExtension("mul", mulExtension).
		LoadExtension("div", divExtension).
		LoadExtension("mod", modExtension).
		LoadExtension("print", printExtension).
		LoadExtension("list", listExtension).
		LoadExtension("append", appendExtension).
		LoadExtension("slice", sliceExtension).
		LoadExtension("peak", peakExtension).
		LoadModule("map", mapModule).
		LoadExtension("type", typeExtension).
		LoadModule("stack", stackModule)
}
./pkg/fp/ast.go
package fp

// Expr : union of Name, LambdaExpr
type Expr interface {
	String() string
}

type Name string

func (e Name) String() string {
	return string(e)
}

// LambdaExpr : S-expression
type LambdaExpr struct {
	Name Name
	Args []Expr
}

func (e LambdaExpr) String() string {
	s := ""
	s += "("
	s += e.Name.String()
	for _, arg := range e.Args {
		s += " " + arg.String()
	}
	s += ")"
	return s
}
./pkg/fp/parser.go
package fp

import (
	"errors"
	"strings"
)

type Token = string

func pop(tokenList []Token) ([]Token, Token, error) {
	if len(tokenList) == 0 {
		return nil, "", errors.New("empty token list")
	}
	return tokenList[1:], tokenList[0], nil
}

// Tokenize : TODO add handling double quotes for string
func Tokenize(str string) []Token {
	// remove comment
	parts := strings.Split(str, "\n")
	var newParts []string
	for _, part := range parts {
		newParts = append(newParts, strings.Split(part, "//")[0])
	}

	str = strings.Join(newParts, "\n")

	str = strings.ReplaceAll(str, "\n", " ")
	str = strings.ReplaceAll(str, "(", " ( ")
	str = strings.ReplaceAll(str, ")", " ) ")

	return strings.Fields(str)
}

func ParseAll(tokenList []Token) ([]Expr, []Token) {
	var expr Expr
	var exprList []Expr
	var err error
	for len(tokenList) > 0 {
		expr, tokenList, err = parseSingle(tokenList)
		if err != nil {
			panic(err)
		}
		exprList = append(exprList, expr)
	}
	return exprList, tokenList
}

type Parser struct {
	Buffer []Token
}

func (p *Parser) Clear() {
	p.Buffer = []Token{}
}

func (p *Parser) Input(tok Token) Expr {
	p.Buffer = append(p.Buffer, tok)
	// try parse single // TODO : do this for simplicity
	buffer := append([]Token(nil), p.Buffer...) // copy
	expr, buffer, err := parseSingle(buffer)
	if err != nil {
		// parse fail - don't do anything
		return nil
	} else {
		// parse ok - update buffer
		p.Buffer = buffer
		return expr
	}
}

func parseSingle(tokenList []Token) (Expr, []Token, error) {
	var parse func(tokenList []Token) (Expr, []Token, bool, error)
	parse = func(tokenList []Token) (Expr, []Token, bool, error) {
		if len(tokenList) == 0 {
			return nil, nil, false, errors.New("empty token list")
		}
		tokenList, head, err := pop(tokenList) // pop ( or [ or name
		if err != nil {
			return nil, nil, false, err
		}
		switch head {
		case "(":
			tokenList, funcName, err := pop(tokenList)
			if err != nil {
				return nil, nil, false, err
			}
			if funcName == ")" { // empty
				return parse(tokenList)
			}
			var expr Expr
			var exprList []Expr
			var endWithClose bool
			for {
				expr, tokenList, endWithClose, err = parse(tokenList)
				if err != nil {
					return nil, nil, false, err
				}
				if endWithClose {
					break
				}
				exprList = append(exprList, expr)
			}
			return LambdaExpr{
				Name: Name(funcName),
				Args: exprList,
			}, tokenList, false, nil
		default:
			return Name(head), tokenList, head == ")", nil
		}
	}

	expr, tokenList, endWithClose, err := parse(tokenList)
	if err != nil {
		return nil, nil, err
	}
	if endWithClose {
		return nil, nil, errors.New("parse error")
	}
	return expr, tokenList, nil
}
./pkg/fp/runtime_module.go
package fp

import (
	"fmt"
)

var letModule = Module{
	Exec: func(r *Runtime, expr LambdaExpr) (Object, error) {
		if len(expr.Args) < 2 {
			return nil, fmt.Errorf("not enough arguments for let")
		}
		name := expr.Args[0].(Name)
		outputs, err := r.stepMany(expr.Args[1:]...)
		if err != nil {
			return nil, err
		}
		r.Stack[len(r.Stack)-1][name] = outputs[len(outputs)-1]
		return outputs[len(outputs)-1], nil
	},
	Man: "module: (let x 3) - assign value 3 to local variable x",
}

var delModule = Module{
	Exec: func(r *Runtime, expr LambdaExpr) (Object, error) {
		if len(expr.Args) < 1 {
			return nil, fmt.Errorf("not enough arguments for del")
		}
		name := expr.Args[0].(Name)
		_, err := r.stepMany(expr.Args[1:]...)
		if err != nil {
			return nil, err
		}
		delete(r.Stack[len(r.Stack)-1], name)
		return nil, nil
	},
	Man: "module: (del x) - delete variable x",
}

var lambdaModule = Module{
	Exec: func(r *Runtime, expr LambdaExpr) (Object, error) {
		v := Lambda{
			Params: nil,
			Impl:   nil,
			Frame:  nil,
		}
		for i := 0; i < len(expr.Args)-1; i++ {
			paramName := expr.Args[i].(Name)
			v.Params = append(v.Params, paramName)
		}
		v.Impl = expr.Args[len(expr.Args)-1]
		v.Frame = make(Frame).Update(r.Stack[len(r.Stack)-1])
		return v, nil
	},
	Man: "module: (lambda x y (add x y) - declare a function",
}

var caseModule = Module{
	Exec: func(r *Runtime, expr LambdaExpr) (Object, error) {
		cond, err := r.Step(expr.Args[0])
		if err != nil {
			return nil, err
		}
		i, err := func() (int, error) {
			for i := 1; i < len(expr.Args); i += 2 {
				if arg, ok := expr.Args[i].(Name); ok && arg == "_" {
					return i, nil
				}
				comp, err := r.Step(expr.Args[i])
				if err != nil {
					return 0, err
				}
				if comp == cond {
					return i, nil
				}
			}
			return 0, fmt.Errorf("runtime error: no case matched %s", expr)
		}()
		if err != nil {
			return nil, err
		}
		return r.Step(expr.Args[i+1])
	},
	Man: "module: (case x 1 2 4 5) - case, if x=1 then return 3, if x=4 the return 5",
}

var resetModule = Module{
	Exec: func(r *Runtime, expr LambdaExpr) (Object, error) {
		r.Stack = []Frame{
			make(Frame),
		}
		return nil, nil
	},
	Man: "module: (reset) - reset stack",
}

var tailExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		return values[len(values)-1], nil
	},
	Man: "extension: (tail (print 1) (print 2) 3) - exec a sequence of expressions and return the last one",
}

var addExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		sum := 0
		for i := 0; i < len(values); i++ {
			v, ok := values[i].(int)
			if !ok {
				return nil, fmt.Errorf("adding non-integer values")
			}
			sum += v
		}
		return sum, nil
	},
	Man: "extension: (add 1 (add 2 3) 3) - exec a sequence of expressions and return the sum",
}

var mulExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		sum := 1
		for i := 0; i < len(values); i++ {
			v, ok := values[i].(int)
			if !ok {
				return nil, fmt.Errorf("multiplying non-integer values")
			}
			sum *= v
		}
		return sum, nil
	},
	Man: "extension: (mul 1 (add 2 3) 3) - exec a sequence of expressions and return the product",
}

var subExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		if len(values) != 2 {
			return nil, fmt.Errorf("subtract requires 2 arguments")
		}
		a, ok := values[0].(int)
		if !ok {
			return nil, fmt.Errorf("subtract non-integer value")
		}
		b, ok := values[1].(int)
		if !ok {
			return nil, fmt.Errorf("subtract non-integer value")
		}
		return a - b, nil
	},
	Man: "extension: (sub 2 (add 1 1)) - exec two expressions and return difference",
}

var divExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		if len(values) != 2 {
			return nil, fmt.Errorf("dividing requires 2 arguments")
		}
		a, ok := values[0].(int)
		if !ok {
			return nil, fmt.Errorf("dividing non-integer value")
		}
		b, ok := values[1].(int)
		if !ok {
			return nil, fmt.Errorf("dividing non-integer value")
		}
		if b == 0 {
			return nil, fmt.Errorf("division by zero")
		}
		return a / b, nil
	},
	Man: "extension: (div 2 (add 1 1)) - exec two expressions and return ratio",
}

var modExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		if len(values) != 2 {
			return nil, fmt.Errorf("dividing requires 2 arguments")
		}
		a, ok := values[0].(int)
		if !ok {
			return nil, fmt.Errorf("dividing non-integer value")
		}
		b, ok := values[1].(int)
		if !ok {
			return nil, fmt.Errorf("dividing non-integer value")
		}
		if b == 0 {
			return nil, fmt.Errorf("division by zero")
		}
		return a % b, nil
	},
	Man: "extension: (mod 2 (add 1 1)) - exec two expressions and return modulo",
}

var signExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		v, ok := values[len(values)-1].(int)
		if !ok {
			return nil, fmt.Errorf("sign non-integer value")
		}
		switch {
		case v > 0:
			return +1, nil
		case v < 0:
			return -1, nil
		default:
			return 0, nil
		}
	},
	Man: "extension: (sign 3) - exec an expression and return the sign",
}

var listExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		var l List
		for _, v := range values {
			l = append(l, v)
		}
		return l, nil
	},
	Man: "extension: (list 1 2 (lambda x (add x 1))) - make a list",
}

var appendExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		l, ok := values[0].(List)
		if !ok {
			return nil, fmt.Errorf("first argument must be list")
		}
		return append(l, values[1:]...), nil
	},
	Man: "extension: (append l 2 (add 1 1)) - append elements into list l and return a new list",
}

var sliceExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		if len(values) != 3 {
			return nil, fmt.Errorf("slice requires 3 arguments")
		}
		l, ok := values[0].(List)
		if !ok {
			return nil, fmt.Errorf("first argument must be list")
		}
		if len(l) < 1 {
			return nil, fmt.Errorf("empty list")
		}
		i, ok := values[1].(int)
		if !ok {
			return nil, fmt.Errorf("second argument must be integer")
		}
		j, ok := values[2].(int)
		if !ok {
			return nil, fmt.Errorf("third argument must be integer")
		}
		return l[i:j], nil
	},
	Man: "extension: (slice l 2 3) - make a slice of a list l[2, 3]",
}

var peakExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		if len(values) >= 2 {
			return nil, fmt.Errorf("peak requires at least 2 arguments")
		}
		l, ok := values[0].(List)
		if !ok {
			return nil, fmt.Errorf("first argument must be list")
		}
		if len(l) < 1 {
			return nil, fmt.Errorf("empty list")
		}
		var outputs List
		for j := 1; j < len(values); j++ {
			i, ok := values[j].(int)
			if !ok {
				return nil, fmt.Errorf("second argument must be integer")
			}
			outputs = append(outputs, l[i])
		}
		if len(outputs) == 1 {
			return outputs[0], nil
		}
		return outputs, nil
	},
	Man: "extension: (peak l 3 2) - get elem from list (can get multiple elements)",
}

var mapModule = Module{
	Exec: func(r *Runtime, expr LambdaExpr) (Object, error) {
		if len(expr.Args) != 2 {
			return nil, fmt.Errorf("map requires 2 arguments")
		}
		l1, err := r.Step(expr.Args[0])
		if err != nil {
			return nil, err
		}
		l, ok := l1.(List)
		if !ok {
			return nil, fmt.Errorf("first argument must be list")
		}
		f1, err := r.Step(expr.Args[1])
		if err != nil {
			return nil, err
		}
		var outputs List
		switch f := f1.(type) {
		case Lambda:
			if len(f.Params) != 1 {
				return nil, fmt.Errorf("map function requires 1 argument")
			}
			for _, v := range l {
				// 2. add argument to local Frame
				localFrame := make(Frame).Update(f.Frame)
				localFrame[f.Params[0]] = v
				// 3. push Frame to Stack
				r.Stack = append(r.Stack, localFrame)
				// 4. exec function
				o, err := r.Step(f.Impl)
				// 5. pop Frame from Stack
				r.Stack = r.Stack[:len(r.Stack)-1]
				// 6. append o
				if err != nil {
					return nil, err
				}
				outputs = append(outputs, o)
			}
		case Module:
			for _, v := range l {
				// 2. add argument to local Frame
				localFrame := make(Frame)
				localFrame["x"] = v // dummy variable
				// 3. make dummy expr and exec
				o, err := f.Exec(r, LambdaExpr{
					Name: "",
					Args: []Expr{Name("x")}, // dummy variable
				})
				// 5. pop Frame from Stack
				r.Stack = r.Stack[:len(r.Stack)-1]
				// 6. append o
				if err != nil {
					return nil, err
				}
				outputs = append(outputs, o)
			}
		default:
			return nil, fmt.Errorf("runtime error: map module requires a function")
		}
		return outputs, nil
	},
	Man: "extension: (map l (lambda y (add 1 y))) - map",
}

// TODO - implement map filter reduce

var typeExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		var types List
		for _, v := range values {
			types = append(types, getType(v))
		}
		if len(types) == 1 {
			return types[0], nil
		}
		return types, nil
	},
	Man: "extension: (type x 1 (lambda y (add 1 y))) - get types of objects (can get multiple ones)",
}

var stackModule = Module{
	Exec: func(r *Runtime, expr LambdaExpr) (Object, error) {
		return r.Stack, nil
	},
	Man: "module: (stack) - get stack",
}

var printExtension = Extension{
	Exec: func(values ...Object) (Object, error) {
		for _, v := range values {
			fmt.Printf("%v ", v)
		}
		fmt.Println()
		return len(values), nil
	},
	Man: "extension: (print 1 x (lambda 3)) - print values",
}
./pkg/fp/runtime_core.go
package fp

import (
	"fmt"
)

type Runtime struct {
	parseLiteral func(lit Name) (Object, error)
	Stack        []Frame `json:"stack,omitempty"`
}
type Frame map[Name]Object

func (f Frame) Update(otherFrame Frame) Frame {
	for k, v := range otherFrame {
		f[k] = v
	}
	return f
}

func (r *Runtime) String() string {
	s := ""
	for i, f := range r.Stack {
		s += "["
		for k, v := range f {
			s += fmt.Sprintf("%s -> %v, ", k, v)
		}
		if i != len(r.Stack)-1 {
			s += "]\n"
		} else {
			s += "]"
		}
	}
	return s
}

func (r *Runtime) LoadModule(name Name, f Module) *Runtime {
	r.Stack[0][name] = f
	return r
}

func (r *Runtime) LoadParseLiteral(f func(lit Name) (Object, error)) *Runtime {
	r.parseLiteral = f
	return r
}

type Extension struct {
	Exec func(...Object) (Object, error)
	Man  string
}

func (r *Runtime) LoadExtension(name Name, e Extension) *Runtime {
	return r.LoadModule(name, Module{
		Exec: func(r *Runtime, expr LambdaExpr) (Object, error) {
			args, err := r.stepMany(expr.Args...)
			if err != nil {
				return nil, err
			}
			return e.Exec(args...)
		},
		Man: e.Man,
	})
}
./pkg/fp/runtime_types.go
package fp

import "fmt"

// types - TODO implement custom data types like Int, List, Dict

// Object : object union of int, Lambda, Module, List - TODO : introduce new data types
type Object interface{}

func getType(o Object) String {
	switch o.(type) {
	case int:
		return "int"
	case String:
		return "String"
	case Lambda:
		return "Lambda"
	case Module:
		return "Module"
	case List:
		return "List"
	default:
		return "unknown"
	}
}

type String string

func (s String) String() string {
	return string(s)
}

type Lambda struct {
	Params []Name `json:"params,omitempty"`
	Impl   Expr   `json:"impl,omitempty"`
	Frame  Frame  `json:"frame,omitempty"`
}

func (l Lambda) String() string {
	return l.Impl.String()
}

type Module struct {
	Exec func(r *Runtime, expr LambdaExpr) (Object, error)
	Man  string `json:"man,omitempty"`
}

func (m Module) String() string {
	return m.Man
}

type List []Object

func (l List) String() string {
	s := ""
	s += "["
	for _, obj := range l {
		s += fmt.Sprintf("%v,", obj)
	}
	s += "]"
	return s
}
./example.lisp
// define multiplication
(let mul
    (lambda x y
        (case (sign y)                         // mul: (x y) -> xy
            0 0                                             // if y = 0, return 0
            -1 (sub 0 (mul x (sub 0 y)))                    // if y < 0, return 0 - x(-y)
            +1 (add x (mul x (sub y 1)))                    // if y > 0, return x + x(y-1)
        )
    )
)

// define modulo
(let mod
    (lambda x y
        (tail                                  // mul: (x y) -> x % y // defined only for positive y
            (let z (sub x y))                               // local var z = x - y
            (print z x y 6)                                // print local value of z (with label 6)
            (case (sign z)
                +1 (mod z y)                                // if x > y, return (x - y) % y
                0  0                                        // if x = y, return 0
                -1 x                                        // if x < y, return x
            )
        )
    )
)




// partial function using lambda
(let addx
    (lambda x
        (lambda y (add x y))
    )
)

// dict_new
(let dict_new (lambda (lambda x 0)))
// dict_get d[x]
(let dict_get (lambda d x (d x)))

// dict_set d[x] = y
(let dict_set (lambda d x y (
    lambda z (
        case z
            x y
            _ (dict_get d z)
    )
)))

(let z 20)
(print z 1)                                            // print z=20 (with label 1)
(print (mul 13 -17) 2)                                 // print 13 * (-17) (with label 2)
(print (mod 17  13) 3)                                 // print 17 % 13 (with label 3)
(print z 4)                                            // print z=20 again (with label 4), verify that the other z is an actual local variable

(let x_v (print 2 5))                                  // declare x_v - (print 2 5) is executed immediately
(let x_f (lambda (print 2 6)))                         // declare x_f - (print 2 6) is not executed immediately
(print 7)                                              // for debugging
(x_f)                                                   // apply x_f - (print 2 6) is executed

(let f (lambda x (add x 1)))                            // define lambda
(print f)                                              // print lambda
(print (f 21) 8)                                       // print 21 + 1 using lambda

(let t 3)
(let add3 (addx t))                                     // partial function
(print (add3 14) 9)


(print (div 6 2))                                      // test extension

(let l (list 1 2 3 5 -7))                        // test list
(let l (append l 6))
(print l)


// define fibonacci

(let fibonacci
    (lambda x
        (case (sign (sub x 1))
            1 (tail
                (let y (fibonacci (sub x 1)))
                (let z (fibonacci (sub x 2)))
                (add y z)
            )
            _ x
        )
    )
)

(print (fibonacci 20) 11)                                // print the 20-th fibonacci

// test map on list
(let x (list 1 2 3))
(map x (lambda y (add 1 y)))
do you have any comment on this?
