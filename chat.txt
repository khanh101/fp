below is the readme and implementation of a simple functional programming language
./README.md
# FP

A simple functional programming language in 130 lines of code with `functions as first-class citizens`. $\mathbb{F}_p$ also denotes the finite field of order $p$ 


## How to implement data structures like list, dict

data structures can be implemented using functions, example below

floating point is useful

## How to handle infix operator?

translate `[<expr_1> <name_1> <expr_2> <name_2> <expr_3>]` into `(<name_1> <expr_1> (<name_2> <expr_2> <expr_3>))` - todo 
## Isn't `(let x 3)` equivalent to `(let x (lambda 3))`?

yes, if functions are pure, then we can consider `(let x <expr>)` as a pure function of the form `(let x (lambda <expr>))`. 
however, if functions are not pure, if `x` is defined locally, `(let f (lambda (x + 3)))` and `let f (x + 3)` are different
since variables are evaluated at definition but functions are only evaluated when it is called,
that is if we pass `f` outside of the function, it no longer valid.
in the code below, i gave an example with `(let x_v (print 2 5))` and `(func x_f (print 2 6))`

## How to handle higher-order functions

higher-order function is already implemented

## Tail call optimization

WIP

## Performance improvement

if we assume functions are pure, one can consider the whole program as a set of expressions (with some dependencies of `let`)
each function call only need its own variable scope, they can execute every expression at the same time (possibly with some waiting for `let` statement) 

## But can it run Doom?

no ðŸ˜…

## language specs

- program : a list of expression
- name and expression: name is a string of characters, e.g. `x`, `mul`, and expression is enclosed with parentheses starting with a name, e.g `(let x 3)`, `(add 1 2)`
- evaluation: in run time, name and expression have an associated value
    - name is evaluated using a pool of variables; in code, it is `sttack`. if a name is not of a variable name declared using `let` or `input`, it is undefined behavior
    - expression is evaluated using its name

- builtin functions: ` let, lambda, case, sign, sub, add, tail`
```
(let <name> <expr>)                                          - assign value of <expr> into local variable <name>
(lambda <name_1> ... <name_n> <expr>)                        - declare an anonymous function
(case <cond> <expr_1> <expr_2>... <key_{n-1}> <expr_n>)      - branching, if <cond> = <key_i> for i odd, return <expr_{i+1}>
(sign <expr>)                                                - return (-1), 0, (+1) according to sign of <expr>
(add <expr_1> ... <expr_n>)                                  - add
(sub <expr_1> <expr_2>)                                      - subtract
(tail <expr_1> ... <expr_n>)                                 - evaluate all expressions then return the last one
                                                               (use to declare local variables, do multistep calculation)
```

- extension functions: `div, print, input, make_list, append_list`

- wildcard symbol: `_` is a special symbol used in `case` to mark every other cases
- no match is `case` is an undefined behavior

## a simple program

```
// define multiplication
(let mul
    (lambda x y
        (case (sign y)                         // mul: (x y) -> xy
            0 0                                             // if y = 0, return 0
            -1 (sub 0 (mul x (sub 0 y)))                    // if y < 0, return 0 - x(-y)
            +1 (add x (mul x (sub y 1)))                    // if y > 0, return x + x(y-1)
        )
    )
)

// define modulo
(let mod
    (lambda x y
        (tail                                  // mul: (x y) -> x % y // defined only for positive y
            (let z (sub x y))                               // local var z = x - y
            (print z x y 6)                                // print local value of z (with label 6)
            (case (sign z)
                +1 (mod z y)                                // if x > y, return (x - y) % y
                0  0                                        // if x = y, return 0
                -1 x                                        // if x < y, return x
            )
        )
    )
)

// define fibonacci

(let fibonacci
    (lambda x
        (case (sign (sub x 1))
            1 (tail
                (let y (fibonacci (sub x 1)))
                (let z (fibonacci (sub x 2)))
                (add y z)
            )
            _ x
        )
    )
)


// partial function using lambda
(let addx
    (lambda x
        (lambda y (add x y))
    )
)

// dict_new
(let dict_new (lambda (lambda x 0)))
// dict_get d[x]
(let dict_get (lambda d x (d x)))

// dict_set d[x] = y
(let dict_set (lambda d x y (
    lambda z (
        case z
            x y
            _ (dict_get d z)
    )
)))

(let z 20)
(print z 1)                                            // print z=20 (with label 1)
(print (mul 13 -17) 2)                                 // print 13 * (-17) (with label 2)
(print (mod 17  13) 3)                                 // print 17 % 13 (with label 3)
(print z 4)                                            // print z=20 again (with label 4), verify that the other z is an actual local variable

(let x_v (print 2 5))                                  // declare x_v - (print 2 5) is executed immediately
(let x_f (lambda (print 2 6)))                         // declare x_f - (print 2 6) is not executed immediately
(print 7)                                              // for debugging
(x_f)                                                   // apply x_f - (print 2 6) is executed

(let f (lambda x (add x 1)))                            // define lambda
(print f)                                              // print lambda
(print (f 21) 8)                                       // print 21 + 1 using lambda

(let t 3)
(let add3 (addx t))                                     // partial function
(print (add3 14) 9)

// dict example
(let d (dict_new))                                      // new dict
(let d (dict_set d 2 300))                                 // set value
(let d (dict_set d 3 500))                                 // set value
(let d (dict_set d 2 200))                                 // set value
(print (dict_get d 2) 11)                                 // should print 200

// end dict example

(print (div 6 2))                                      // test extension

(let l (make_list 1 2 3 5 -7))                        // test list
(let l (append_list l 6))
(print l)

(let x (input))                                           // waiting for user input
(print (fibonacci x) 11)                                // print the x-th fibonacci


```
./bin/test/main.go
package main

import (
	"fmt"
	"fp/pkg/fp"
	"os"
)

func main() {
	buffer, err := os.ReadFile("example.lisp")
	if err != nil {
		panic(err)
	}
	str := string(buffer)
	tokenList := fp.Tokenize(str)

	exprList, tokenList := fp.ParseAll(tokenList)
	if len(tokenList) > 0 {
		panic("parse error")
	}

	r := fp.NewBasicRuntime().WithArithmeticExtension("div", func(nums ...fp.Object) fp.Object {
		if len(nums) != 2 {
			panic("runtime error")
		}
		return nums[0].(int) / nums[1].(int)
	}).WithArithmeticExtension("print", func(nums ...fp.Object) fp.Object {
		for _, num := range nums {
			fmt.Printf("%v ", num)
		}
		fmt.Println()
		return len(nums)
	}).WithArithmeticExtension("input", func(nums ...fp.Object) fp.Object {
		var v int
		_, err := fmt.Scanf("%d", &v)
		if err != nil {
			panic(err)
		}
		return v
	}).WithArithmeticExtension("make_list", func(nums ...fp.Object) fp.Object {
		var v []fp.Object
		for _, num := range nums {
			v = append(v, num)
		}
		return v
	}).WithArithmeticExtension("append_list", func(nums ...fp.Object) fp.Object {
		return append(nums[0].([]fp.Object), nums[1:]...)
	})
	for _, expr := range exprList {
		r.Step(expr)
	}
}
./pkg/fp/runtime_option.go
package fp

type StepOption func(*stepOption) *stepOption
type stepOption struct {
	tailCallOptimization bool
}

func defaultStepOption() *stepOption {
	return &stepOption{
		tailCallOptimization: false,
	}
}

func WithTailCallOptimization(o *stepOption) *stepOption {
	o.tailCallOptimization = false // TODO - debug tailcall
	return o
}
./pkg/fp/runtime.go
package fp

import "strconv"

// NewPlainRuntime - runtime + core control flow extensions
func NewPlainRuntime() *Runtime {
	return (&Runtime{
		Stack: []Frame{
			make(Frame),
		},
		parseToken: func(expr string) (interface{}, error) {
			return strconv.Atoi(expr)
		},
		extension: make(map[Name]func(r *Runtime, expr LambdaExpr) Object),
	}).
		WithExtension("let", letExtension).
		WithExtension("lambda", lambdaExtension).
		WithExtension("case", caseExtension)
}

// NewBasicRuntime : NewPlainRuntime + minimal set of arithmetic extensions for Turing completeness
func NewBasicRuntime() *Runtime {
	return NewPlainRuntime().
		WithArithmeticExtension("tail", tailArithmeticExtension).
		WithArithmeticExtension("add", addArithmeticExtension).
		WithArithmeticExtension("sub", subArithmeticExtension).
		WithArithmeticExtension("sign", signArithmeticExtension)
}
./pkg/fp/runtime_extension.go
package fp

type ArithmeticExtension = func(...Object) Object

func (r *Runtime) stepWithTailCallOptimization(exprList ...Expr) []Object {
	var outputs []Object
	for i := 0; i < len(exprList)-1; i++ {
		outputs = append(outputs, r.Step(exprList[i]))
	}
	if len(exprList) > 0 {
		outputs = append(outputs, r.Step(exprList[len(exprList)-1], WithTailCallOptimization))
	}
	return outputs
}

func (r *Runtime) WithArithmeticExtension(name Name, f ArithmeticExtension) *Runtime {
	return r.WithExtension(name, func(r *Runtime, expr LambdaExpr) Object {
		return f(r.stepWithTailCallOptimization(expr.Args...)...)
	})
}

func letExtension(r *Runtime, expr LambdaExpr) Object {
	name := expr.Args[0].(Name)
	outputs := r.stepWithTailCallOptimization(expr.Args[1:]...)
	r.Stack[len(r.Stack)-1][name] = outputs[len(outputs)-1]
	return 0
}

func lambdaExtension(r *Runtime, expr LambdaExpr) Object {
	v := Lambda{
		Params: nil,
		Impl:   nil,
		Frame:  nil,
	}
	for i := 0; i < len(expr.Args)-1; i++ {
		paramName := expr.Args[i].(Name)
		v.Params = append(v.Params, paramName)
	}
	v.Impl = expr.Args[len(expr.Args)-1]
	v.Frame = make(Frame).Update(r.Stack[len(r.Stack)-1])
	return v
}

func caseExtension(r *Runtime, expr LambdaExpr) Object {
	cond := r.Step(expr.Args[0])
	i := func() int {
		for i := 1; i < len(expr.Args); i += 2 {
			if arg, ok := expr.Args[i].(Name); ok && arg == "_" {
				return i
			}
			if r.Step(expr.Args[i]) == cond {
				return i
			}
		}
		panicError("runtime error: no case matched %s", expr)
		return 0
	}()
	return r.Step(expr.Args[i+1], WithTailCallOptimization)
}

func tailArithmeticExtension(value ...Object) Object {
	return value[len(value)-1]
}

func addArithmeticExtension(value ...Object) Object {
	v := 0
	for i := 0; i < len(value); i++ {
		v += value[i].(int)
	}
	return v
}

func subArithmeticExtension(value ...Object) Object {
	if len(value) != 2 {
		panicError("runtime error: sub arithmetic extension requires 2 arguments %s")
	}
	return value[0].(int) - value[1].(int)
}

func signArithmeticExtension(value ...Object) Object {
	v := value[len(value)-1].(int)
	switch {
	case v > 0:
		return +1
	case v < 0:
		return -1
	default:
		return 0
	}
}
./pkg/fp/util.go
package fp

import (
	"fmt"
	"os"
)

func panicError(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(os.Stderr, "ERROR: "+format, args...)
}
func logWarn(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(os.Stderr, "WARNING: "+format, args...)
}

func logInfo(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(os.Stdout, "INFO: "+format, args...)
}

func logDebug(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(os.Stdout, "DEBUG"+format, args...)
}
./pkg/fp/ast.go
package fp

// Expr : union of Name, LambdaExpr
type Expr interface {
	String() string
}

type Name string

func (e Name) String() string {
	return string(e)
}

// LambdaExpr : S-expression
type LambdaExpr struct {
	Name Name
	Args []Expr
}

func (e LambdaExpr) String() string {
	s := ""
	s += "("
	s += e.Name.String()
	for _, arg := range e.Args {
		s += " " + arg.String()
	}
	s += ")"
	return s
}
./pkg/fp/parser.go
package fp

import (
	"strings"
)

type Token = string

func pop(tokenList []Token) ([]Token, Token) {
	return tokenList[1:], tokenList[0]
}

func peak(tokenList []Token) Token {
	return tokenList[0]
}

func Tokenize(str string) []Token {
	// remove comment
	parts := strings.Split(str, "\n")
	newParts := []string{}
	for _, part := range parts {
		newParts = append(newParts, strings.Split(part, "//")[0])
	}

	str = strings.Join(newParts, "\n")

	str = strings.ReplaceAll(str, "\n", " ")
	str = strings.ReplaceAll(str, "(", " ( ")
	str = strings.ReplaceAll(str, ")", " ) ")

	return strings.Fields(str)
}

func ParseAll(tokenList []Token) ([]Expr, []Token) {
	var expr Expr
	var exprList []Expr
	for {
		if len(tokenList) == 0 || peak(tokenList) == ")" {
			break
		}
		expr, tokenList = parse(tokenList)
		exprList = append(exprList, expr)
	}
	return exprList, tokenList
}

func parse(tokenList []Token) (Expr, []Token) {
	if len(tokenList) == 0 {
		return nil, nil
	}
	tokenList, head := pop(tokenList) // pop ( or [ or name
	switch head {
	case "(":
		tokenList, funcName := pop(tokenList)
		exprList, tokenList := ParseAll(tokenList)
		tokenList, tail := pop(tokenList) // pop )
		if tail != ")" {
			panic("parse error")
		}
		return LambdaExpr{
			Name: Name(funcName),
			Args: exprList,
		}, tokenList
	default:
		return Name(head), tokenList
	}
}
./pkg/fp/runtime_core.go
package fp

import (
	"fmt"
	"os"
)

const DETECT_NONPURE = true

// Object : object union of int, string, Lambda - TODO : introduce new data types
type Object interface{}
type Lambda struct {
	Params []Name
	Impl   Expr
	Frame  Frame
}

func (l Lambda) String() string {
	return l.Impl.String()
}

type Frame map[Name]Object

func (f Frame) Update(otherFrame Frame) Frame {
	for k, v := range otherFrame {
		f[k] = v
	}
	return f
}

type Extension = func(r *Runtime, expr LambdaExpr) Object
type Runtime struct {
	Stack      []Frame
	parseToken func(Token) (interface{}, error)
	extension  map[Name]Extension
}

func (r *Runtime) WithExtension(name Name, f Extension) *Runtime {
	r.extension[name] = f
	return r
}

// Step - implement minimal set of instructions for the language to be Turing complete
// let, Lambda, case, sign, sub, add, tail
func (r *Runtime) Step(expr Expr, stepOptions ...StepOption) Object {
	o := defaultStepOption()
	for _, opt := range stepOptions {
		o = opt(o)
	}
	switch expr := expr.(type) {
	case Name:
		var v Object
		// parse token
		v, err := r.parseToken(string(expr))
		if err == nil {
			return v
		}
		// find in stack
		for i := len(r.Stack) - 1; i >= 0; i-- {
			if v, ok := r.Stack[i][expr]; ok {
				if DETECT_NONPURE && i != 0 && i < len(r.Stack)-1 {
					_, _ = fmt.Fprintf(os.Stderr, "non-pure function")
				}
				return v
			}
		}
		panicError("runtime error: variable %s not found", expr.String())
	case LambdaExpr:
		// check for user-defined function
		if f, ok := func() (Lambda, bool) {
			// 1. get func recursively
			for i := len(r.Stack) - 1; i >= 0; i-- {
				if f, ok := r.Stack[i][expr.Name]; ok {
					if DETECT_NONPURE && i != 0 && i < len(r.Stack)-1 {
						_, _ = fmt.Fprintf(os.Stderr, "non-pure function")
					}
					return f.(Lambda), true
				}
			}
			return Lambda{}, false
		}(); ok {
			// 1. evaluate arguments
			var args []Object
			for _, arg := range expr.Args {
				args = append(args, r.Step(arg))
			}
			if o.tailCallOptimization {
				// tail call - use last frame
				for i := 0; i < len(f.Params); i++ {
					r.Stack[len(r.Stack)-1][f.Params[i]] = args[i]
				}
			} else {
				// 2. add argument to local Frame
				localFrame := make(Frame).Update(f.Frame)
				for i := 0; i < len(f.Params); i++ {
					localFrame[f.Params[i]] = args[i]
				}
				// 3. push Frame to Stack
				r.Stack = append(r.Stack, localFrame)
			}
			// 4. exec function
			v := r.Step(f.Impl)
			if o.tailCallOptimization {
				// pass
			} else {
				// 5. pop Frame from Stack
				r.Stack = r.Stack[:len(r.Stack)-1]
			}
			return v
		}
		// check for extension
		if f, ok := r.extension[expr.Name]; ok {
			return f(r, expr)
		}
		panicError("runtime error: function %s not found", expr.Name.String())
	default:
		panicError("runtime error: unknown expression type")
	}
	panicError("unreachable")
	return nil
}
./example.lisp
// define multiplication
(let mul
    (lambda x y
        (case (sign y)                         // mul: (x y) -> xy
            0 0                                             // if y = 0, return 0
            -1 (sub 0 (mul x (sub 0 y)))                    // if y < 0, return 0 - x(-y)
            +1 (add x (mul x (sub y 1)))                    // if y > 0, return x + x(y-1)
        )
    )
)

// define modulo
(let mod
    (lambda x y
        (tail                                  // mul: (x y) -> x % y // defined only for positive y
            (let z (sub x y))                               // local var z = x - y
            (print z x y 6)                                // print local value of z (with label 6)
            (case (sign z)
                +1 (mod z y)                                // if x > y, return (x - y) % y
                0  0                                        // if x = y, return 0
                -1 x                                        // if x < y, return x
            )
        )
    )
)

// define fibonacci

(let fibonacci
    (lambda x
        (case (sign (sub x 1))
            1 (tail
                (let y (fibonacci (sub x 1)))
                (let z (fibonacci (sub x 2)))
                (add y z)
            )
            _ x
        )
    )
)


// partial function using lambda
(let addx
    (lambda x
        (lambda y (add x y))
    )
)

// dict_new
(let dict_new (lambda (lambda x 0)))
// dict_get d[x]
(let dict_get (lambda d x (d x)))

// dict_set d[x] = y
(let dict_set (lambda d x y (
    lambda z (
        case z
            x y
            _ (dict_get d z)
    )
)))

(let z 20)
(print z 1)                                            // print z=20 (with label 1)
(print (mul 13 -17) 2)                                 // print 13 * (-17) (with label 2)
(print (mod 17  13) 3)                                 // print 17 % 13 (with label 3)
(print z 4)                                            // print z=20 again (with label 4), verify that the other z is an actual local variable

(let x_v (print 2 5))                                  // declare x_v - (print 2 5) is executed immediately
(let x_f (lambda (print 2 6)))                         // declare x_f - (print 2 6) is not executed immediately
(print 7)                                              // for debugging
(x_f)                                                   // apply x_f - (print 2 6) is executed

(let f (lambda x (add x 1)))                            // define lambda
(print f)                                              // print lambda
(print (f 21) 8)                                       // print 21 + 1 using lambda

(let t 3)
(let add3 (addx t))                                     // partial function
(print (add3 14) 9)

// dict example
(let d (dict_new))                                      // new dict
(let d (dict_set d 2 300))                                 // set value
(let d (dict_set d 3 500))                                 // set value
(let d (dict_set d 2 200))                                 // set value
(print (dict_get d 2) 11)                                 // should print 200

// end dict example

(print (div 6 2))                                      // test extension

(let l (make_list 1 2 3 5 -7))                        // test list
(let l (append_list l 6))
(print l)

(let x (input))                                           // waiting for user input
(print (fibonacci x) 11)                                // print the x-th fibonacci

do you have any comment on this?
